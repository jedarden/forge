//! Configuration and launcher script generation.
//!
//! Generates ~/.forge/config.yaml and launcher scripts based on detected CLI tools.

use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};
use thiserror::Error;
use tracing::{debug, info};

use crate::detection::CliToolDetection;

/// Errors that can occur during config generation.
#[derive(Debug, Error)]
pub enum GeneratorError {
    #[error("Failed to create directory: {0}")]
    DirectoryCreationFailed(String),

    #[error("Failed to write file: {0}")]
    FileWriteFailed(String),

    #[error("Failed to set permissions: {0}")]
    PermissionsFailed(String),

    #[error("Tool not supported: {0}")]
    UnsupportedTool(String),
}

/// Result type for generator operations.
pub type Result<T> = std::result::Result<T, GeneratorError>;

/// Generate config.yaml from detected CLI tool.
///
/// Creates a complete forge configuration file with the selected tool
/// configured as the chat backend.
pub fn generate_config_yaml(tool: &CliToolDetection, config_path: &Path) -> Result<()> {
    info!("Generating config.yaml for {} at {}", tool.name, config_path.display());

    let config_content = match tool.name.as_str() {
        "claude-code" => generate_claude_config(tool),
        "opencode" => generate_opencode_config(tool),
        _ => return Err(GeneratorError::UnsupportedTool(tool.name.clone())),
    };

    fs::write(config_path, config_content)
        .map_err(|e| GeneratorError::FileWriteFailed(e.to_string()))?;

    info!("Config generated successfully");
    Ok(())
}

/// Generate config for Claude Code.
fn generate_claude_config(tool: &CliToolDetection) -> String {
    let binary_path = tool.binary_path.display();
    let version = tool.version.as_deref().unwrap_or("unknown");

    format!(r#"# FORGE Configuration
# Auto-generated by forge init
# CLI Tool: Claude Code ({version})
# Binary: {binary_path}
# Generated: {timestamp}

chat_backend:
  command: claude
  args:
    - --dangerously-skip-permissions
    - --output-format
    - stream-json
  model: sonnet
  timeout: 30
  max_retries: 3

launchers:
  claude-code:
    executable: ~/.forge/launchers/claude-code-launcher
    models:
      - sonnet
      - opus
      - haiku

log_collection:
  paths:
    - ~/.forge/logs/*.log
  format: jsonl
  poll_interval_seconds: 1
  max_age_days: 30
  max_size_mb: 1000

status_path: ~/.forge/status/

cost_tracking:
  enabled: true
  database_path: ~/.forge/forge_costs.db
  forecast_days: 30

dashboard:
  refresh_interval_ms: 1000
  max_fps: 60
  default_layout: overview

hotkeys:
  workers_view: w
  tasks_view: t
  costs_view: c
  metrics_view: m
  logs_view: l
  overview: o
  spawn_worker: s
  kill_worker: k
  chat_input: ':'

routing:
  priority_tiers:
    P0: premium
    P1: premium
    P2: standard
    P3: budget
    P4: budget
  subscription_first: true
  fallback_to_api: true
"#,
        version = version,
        binary_path = binary_path,
        timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S")
    )
}

/// Generate config for OpenCode.
fn generate_opencode_config(tool: &CliToolDetection) -> String {
    let binary_path = tool.binary_path.display();
    let version = tool.version.as_deref().unwrap_or("unknown");

    format!(r#"# FORGE Configuration
# Auto-generated by forge init
# CLI Tool: OpenCode ({version})
# Binary: {binary_path}
# Generated: {timestamp}

chat_backend:
  command: opencode
  args:
    - --output-format
    - stream-json
  model: sonnet
  timeout: 30
  max_retries: 3

launchers:
  opencode:
    executable: ~/.forge/launchers/opencode-launcher
    models:
      - sonnet
      - opus

log_collection:
  paths:
    - ~/.forge/logs/*.log
  format: jsonl
  poll_interval_seconds: 1
  max_age_days: 30
  max_size_mb: 1000

status_path: ~/.forge/status/

cost_tracking:
  enabled: true
  database_path: ~/.forge/forge_costs.db
  forecast_days: 30

dashboard:
  refresh_interval_ms: 1000
  max_fps: 60
  default_layout: overview

hotkeys:
  workers_view: w
  tasks_view: t
  costs_view: c
  metrics_view: m
  logs_view: l
  overview: o
  spawn_worker: s
  kill_worker: k
  chat_input: ':'

routing:
  priority_tiers:
    P0: premium
    P1: premium
    P2: standard
    P3: budget
    P4: budget
  subscription_first: true
  fallback_to_api: true
"#,
        version = version,
        binary_path = binary_path,
        timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S")
    )
}

/// Generate launcher script for detected CLI tool.
///
/// Creates an executable bash script that follows the standard launcher protocol
/// defined in ADR 0005 and ADR 0015.
pub fn generate_launcher_script(tool: &CliToolDetection, launcher_path: &Path) -> Result<()> {
    info!("Generating launcher script for {} at {}", tool.name, launcher_path.display());

    let script_content = match tool.name.as_str() {
        "claude-code" => generate_claude_launcher(tool),
        "opencode" => generate_opencode_launcher(tool),
        _ => return Err(GeneratorError::UnsupportedTool(tool.name.clone())),
    };

    // Write script
    fs::write(launcher_path, script_content)
        .map_err(|e| GeneratorError::FileWriteFailed(e.to_string()))?;

    // Make executable (chmod +x)
    #[cfg(unix)]
    {
        let mut permissions = fs::metadata(launcher_path)
            .map_err(|e| GeneratorError::PermissionsFailed(e.to_string()))?
            .permissions();
        permissions.set_mode(0o755); // rwxr-xr-x
        fs::set_permissions(launcher_path, permissions)
            .map_err(|e| GeneratorError::PermissionsFailed(e.to_string()))?;
    }

    info!("Launcher script generated successfully");
    Ok(())
}

/// Generate Claude Code launcher script.
fn generate_claude_launcher(tool: &CliToolDetection) -> String {
    let binary_path = tool.binary_path.display();

    format!(r#"#!/usr/bin/env bash
# Claude Code Worker Launcher
# Auto-generated by forge init
# Binary: {binary_path}

set -euo pipefail

MODEL="${{1:-sonnet}}"
WORKSPACE="${{2:-$PWD}}"
SESSION_NAME="${{3:-claude-code-worker-$$}}"

# Create directories
mkdir -p ~/.forge/logs ~/.forge/status

# Map model names to Claude Code model IDs
case "$MODEL" in
    "sonnet") MODEL_ID="claude-sonnet-4.5" ;;
    "opus") MODEL_ID="claude-opus-4.6" ;;
    "haiku") MODEL_ID="claude-haiku-4.5" ;;
    *) MODEL_ID="$MODEL" ;;
esac

# Check if session already exists
if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo "Error: Session '$SESSION_NAME' already exists"
    exit 1
fi

# Launch Claude Code in tmux with logging
tmux new-session -d -s "$SESSION_NAME" \
    "cd \"$WORKSPACE\" && \
     {binary_path} --model=$MODEL_ID \
           --dangerously-skip-permissions \
           --output-format stream-json \
           2>&1 | tee ~/.forge/logs/$SESSION_NAME.log"

# Get PID
sleep 1
PID=$(tmux list-panes -t "$SESSION_NAME" -F '#{{pane_pid}}' 2>/dev/null || echo "unknown")

# Output metadata (JSON)
cat << EOF
{{
  "worker_id": "$SESSION_NAME",
  "pid": $PID,
  "status": "spawned",
  "model": "$MODEL",
  "workspace": "$WORKSPACE"
}}
EOF

# Create status file
cat > ~/.forge/status/$SESSION_NAME.json << EOF
{{
  "worker_id": "$SESSION_NAME",
  "status": "active",
  "model": "$MODEL",
  "model_id": "$MODEL_ID",
  "workspace": "$WORKSPACE",
  "pid": $PID,
  "started_at": "$(date -Iseconds)",
  "last_activity": "$(date -Iseconds)"
}}
EOF

echo "Worker launched in tmux session: $SESSION_NAME"
echo "  Attach: tmux attach -t $SESSION_NAME"
echo "  Logs: tail -f ~/.forge/logs/$SESSION_NAME.log"
"#,
        binary_path = binary_path
    )
}

/// Generate OpenCode launcher script.
fn generate_opencode_launcher(tool: &CliToolDetection) -> String {
    let binary_path = tool.binary_path.display();

    format!(r#"#!/usr/bin/env bash
# OpenCode Worker Launcher
# Auto-generated by forge init
# Binary: {binary_path}

set -euo pipefail

MODEL="${{1:-sonnet}}"
WORKSPACE="${{2:-$PWD}}"
SESSION_NAME="${{3:-opencode-worker-$$}}"

# Create directories
mkdir -p ~/.forge/logs ~/.forge/status

# Check if session already exists
if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo "Error: Session '$SESSION_NAME' already exists"
    exit 1
fi

# Launch OpenCode in tmux with logging
tmux new-session -d -s "$SESSION_NAME" \
    "cd \"$WORKSPACE\" && \
     {binary_path} --model=$MODEL \
           --output-format stream-json \
           2>&1 | tee ~/.forge/logs/$SESSION_NAME.log"

# Get PID
sleep 1
PID=$(tmux list-panes -t "$SESSION_NAME" -F '#{{pane_pid}}' 2>/dev/null || echo "unknown")

# Output metadata (JSON)
cat << EOF
{{
  "worker_id": "$SESSION_NAME",
  "pid": $PID,
  "status": "spawned",
  "model": "$MODEL",
  "workspace": "$WORKSPACE"
}}
EOF

# Create status file
cat > ~/.forge/status/$SESSION_NAME.json << EOF
{{
  "worker_id": "$SESSION_NAME",
  "status": "active",
  "model": "$MODEL",
  "workspace": "$WORKSPACE",
  "pid": $PID,
  "started_at": "$(date -Iseconds)",
  "last_activity": "$(date -Iseconds)"
}}
EOF

echo "Worker launched in tmux session: $SESSION_NAME"
echo "  Attach: tmux attach -t $SESSION_NAME"
echo "  Logs: tail -f ~/.forge/logs/$SESSION_NAME.log"
"#,
        binary_path = binary_path
    )
}

/// Create ~/.forge/ directory structure.
///
/// Creates all required directories for FORGE operation:
/// - ~/.forge/logs - Worker log files
/// - ~/.forge/status - Worker status JSON files
/// - ~/.forge/launchers - Launcher scripts
/// - ~/.forge/workers - Worker configurations
/// - ~/.forge/layouts - Saved dashboard layouts
pub fn create_directory_structure(forge_dir: &Path) -> Result<()> {
    info!("Creating directory structure at {}", forge_dir.display());

    let subdirs = [
        "logs",
        "status",
        "launchers",
        "workers",
        "layouts",
    ];

    for subdir in &subdirs {
        let path = forge_dir.join(subdir);
        debug!("Creating directory: {}", path.display());
        fs::create_dir_all(&path)
            .map_err(|e| GeneratorError::DirectoryCreationFailed(
                format!("{}: {}", path.display(), e)
            ))?;
    }

    // Create .gitignore
    let gitignore_path = forge_dir.join(".gitignore");
    let gitignore_content = r#"# FORGE generated files
*.db
*.db-shm
*.db-wal
logs/
status/
*.log
*.jsonl
chat-audit.jsonl

# Keep structure
!.gitkeep
"#;
    fs::write(gitignore_path, gitignore_content)
        .map_err(|e| GeneratorError::FileWriteFailed(e.to_string()))?;

    info!("Directory structure created successfully");
    Ok(())
}

/// Get the default FORGE directory path (~/.forge).
pub fn get_default_forge_dir() -> PathBuf {
    dirs::home_dir()
        .expect("Could not determine home directory")
        .join(".forge")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::detection::ToolStatus;
    use tempfile::TempDir;

    fn create_test_tool(name: &str) -> CliToolDetection {
        CliToolDetection::new(name, PathBuf::from("/usr/bin/test"))
            .with_version("1.0.0")
            .with_status(ToolStatus::Ready)
    }

    #[test]
    fn test_generate_claude_config() {
        let tool = create_test_tool("claude-code");
        let config = generate_claude_config(&tool);

        assert!(config.contains("Claude Code"));
        assert!(config.contains("chat_backend:"));
        assert!(config.contains("command: claude"));
        assert!(config.contains("--dangerously-skip-permissions"));
    }

    #[test]
    fn test_generate_opencode_config() {
        let tool = create_test_tool("opencode");
        let config = generate_opencode_config(&tool);

        assert!(config.contains("OpenCode"));
        assert!(config.contains("command: opencode"));
        assert!(config.contains("--output-format"));
    }

    #[test]
    fn test_generate_claude_launcher() {
        let tool = create_test_tool("claude-code");
        let script = generate_claude_launcher(&tool);

        assert!(script.starts_with("#!/usr/bin/env bash"));
        assert!(script.contains("Claude Code Worker Launcher"));
        assert!(script.contains("--dangerously-skip-permissions"));
        assert!(script.contains("tmux new-session"));
    }

    #[test]
    fn test_create_directory_structure() {
        let temp = TempDir::new().unwrap();
        let forge_dir = temp.path().join(".forge");

        create_directory_structure(&forge_dir).unwrap();

        assert!(forge_dir.join("logs").exists());
        assert!(forge_dir.join("status").exists());
        assert!(forge_dir.join("launchers").exists());
        assert!(forge_dir.join("workers").exists());
        assert!(forge_dir.join("layouts").exists());
        assert!(forge_dir.join(".gitignore").exists());
    }

    #[test]
    fn test_generate_config_yaml() {
        let temp = TempDir::new().unwrap();
        let config_path = temp.path().join("config.yaml");
        let tool = create_test_tool("claude-code");

        generate_config_yaml(&tool, &config_path).unwrap();

        assert!(config_path.exists());
        let content = fs::read_to_string(config_path).unwrap();
        assert!(content.contains("chat_backend:"));
        assert!(content.contains("command: claude"));
    }
}
